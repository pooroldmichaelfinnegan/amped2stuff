'''[ 'NAME',       'pneumonics',          'description' ]    index is opcode'''
opcodes = [
    ['MOVE', 'A B', 'R(A) := R(B)', 'Copy a value between registers]'],
    ['LOADK', 'A Bx', 'R(A) := K(Bx)', 'Load a constant into a register]'],
    ['LOADBOOL', 'A B C', 'R(A) := (Bool)B; if (C) PC++', 'Load a boolean into a register]'],
    ['LOADNIL', 'A B', 'R(A) := ... := R(B) := nil', 'Load nil values into a range of registers]'],
    ['GETUPVAL', 'A B', 'R(A) := U[B]', 'Read an upvalue into a register]'],
    ['GETGLOBAL', 'A Bx', 'R(A) := G[K(Bx)]', 'Read a global variable into a register]'],
    ['GETTABLE', 'A B C', 'R(A) := R(B)[RK(C)]', 'Read a table element into a register]'],
    ['SETGLOBAL', 'A Bx', 'G[K(Bx)] := R(A)', 'Write a register value into a global variable]'],
    ['SETUPVAL', 'A B', 'U[B] := R(A)', 'Write a register value into an upvalue]'],
    ['SETTABLE', 'A B C', 'R(A)[RK(B)] := RK(C)', 'Write a register value into a table element]'],
    ['NEWTABLE', 'A B C', 'R(A) := {{}} (size = B.C)', 'Create a new table]'],
    ['SELF', 'A B C', 'R(A+1) := R(B); R(A) := R(B)[RK(C)]', 'Prepare an object method for calling]'],
    ['ADD', 'A B C', 'R(A) := RK(B) + RK(C)', 'Addition]'],
    ['SUB', 'A B C', 'R(A) := RK(B) - RK(C)', 'Subtraction]'],
    ['MUL', 'A B C', 'R(A) := RK(B) * RK(C)', 'Multiplication]'],
    ['DIV', 'A B C', 'R(A) := RK(B) / RK(C)', 'Division]'],
    ['POW', 'A B C', 'R(A) := RK(B) ^ RK(C)', 'Exponentiation]'],
    ['UNM', 'A B', 'R(A) := -R(B)', 'Unary minus]'],
    ['NOT', 'A B', 'R(A) := not R(B)', 'Logical NOT]'],
    ['CONCAT', 'A B C', 'R(A) := R(B) .. ... .. R(C)', 'Concatenate a range of registers]'],
    ['JMP', 'sBx', 'PC += sBx', 'Unconditional jump]'],
    ['EQ', 'A B C', 'if ((RK(B) == RK(C)) ~= A) then PC++', 'Equality test]'],
    ['LT', 'A B C', 'if ((RK(B) < RK(C)) ~= A) then PC++', 'Less than test]'],
    ['LE', 'A B C', 'if ((RK(B) <= RK(C)) ~= A) then PC++', 'Less than or equal to test]'],
    ['TEST', 'A B C', 'if (R(B) <=> C) then R(A) := R(B) else PC++', 'Test for short-circuit logical and and or evaluation]'],
    ['CALL', 'A B C', 'R(A). ... .R(A+C-2) := R(A)(R(A+1). ... .R(A+B-1))', 'Call a closure]'],
    ['TAILCALL', 'A B C', 'return R(A)(R(A+1). ... .R(A+B-1))', 'Perform a tail call]'],
    ['RETURN', 'A B', 'return R(A). ... .R(A+B-2) (see note)', 'Return from function call]'],
    ['FORLOOP', 'A sBx', 'R(A)+=R(A+2); if R(A) <?= R(A+1) then PC+= sBx', 'Iterate a numeric for loop]'],
    ['TFORLOOP', 'A C', 'R(A+2). ... .R(A+2+C) := R(A)(R(A+1). R(A+2));', 'Iterate a generic for loop]'],
    ['TFORPREP', 'A sBx', 'if type(R(A)) == table then R(A+1):=R(A). R(A):=next;', 'Initialization for a generic for loop]'],
    ['SETLIST', 'A Bx', 'R(A)[Bx-Bx%%FPF+i] := R(A+i). 1 <= i <= Bx%%FPF+1', 'Set a range of array elements for a table]'],
    ['SETLISTO', 'A Bx', 'Set a variable number of table elements]'],
    ['CLOSE', 'A close stack variables up to R(A)', 'Close a range of locals being used as upvalues]'],
    ['CLOSURE', 'A Bx R(A) := closure(KPROTO[Bx]. R(A). ... .R(A+n))', 'Create a closure of a function prototy']
]